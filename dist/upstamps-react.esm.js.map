{"version":3,"file":"upstamps-react.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Utils/constants.ts","../src/Contexts/Context.tsx","../src/Contexts/useUpstampsContext.tsx","../src/Flags/useFlag.tsx","../src/Flags/Flag.tsx","../src/Remotes/useRemoteFlag.tsx","../src/Remotes/RemoteFlag.tsx","../src/ABTests/shared.ts","../src/ABTests/useABTest.tsx","../src/ABTests/ABTest.tsx","../src/Utils/functions.ts","../src/Segments/shared.ts","../src/Segments/useSegment.tsx","../src/Segments/Segment.tsx","../src/Scopes/ScopeContext.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export const apiUrl: string = \"https://services.upstamps.com/api\";\n","import React, { createContext, useEffect, useReducer, useMemo } from \"react\";\n//Constants\nimport { apiUrl } from \"../Utils/constants\";\n//Utils\nimport localForage from \"localforage\";\n\nexport interface UpStampsConfigParams {\n  clientId: string;\n  envKey: string;\n  projectKey: string;\n}\n\nexport interface UpStampsState {\n  loading: boolean;\n  error: boolean;\n  flags: Array<string>;\n  remotes: Array<{ name: string; data: {} }>;\n  params: UpStampsConfigParams;\n}\n\nexport interface UpStampsContextState {\n  state: UpStampsState;\n}\n\nexport interface UpStampsProviderProps extends UpStampsConfigParams {\n  children: React.ReactNode;\n}\n\nexport type ReducerSetFlags = {\n  type: \"set-flags\";\n  payload: {\n    flags: Array<string>;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetFlagsError = {\n  type: \"set-flags-error\";\n  payload: {\n    error: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetRemotes = {\n  type: \"set-remotes\";\n  payload: {\n    remotes: Array<{\n      name: string;\n      data: {};\n    }>;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetRemotesError = {\n  type: \"set-remotes-error\";\n  payload: {\n    error: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerActions =\n  | ReducerSetFlags\n  | ReducerSetFlagsError\n  | ReducerSetRemotes\n  | ReducerSetRemotesError;\n\nexport const UpStampsContext = createContext<UpStampsContextState>(\n  {} as UpStampsContextState\n);\n\nlet reducer = (state: UpStampsState, action: ReducerActions) => {\n  switch (action.type) {\n    case \"set-flags\":\n      return { ...state, ...action.payload };\n    case \"set-flags-error\":\n      return { ...state, ...action.payload };\n    case \"set-remotes\":\n      return { ...state, ...action.payload };\n    case \"set-remotes-error\":\n      return { ...state, ...action.payload };\n\n    default:\n      throw new Error(`Unhandled action type`);\n  }\n};\n\nexport const UpStampsProvider: React.FC<UpStampsProviderProps> = ({\n  children,\n  clientId,\n  envKey,\n  projectKey\n}) => {\n  const params = {\n    clientId,\n    envKey,\n    projectKey\n  };\n\n  const [state, dispatch] = useReducer(reducer, {\n    loading: true,\n    error: false,\n    flags: [],\n    remotes: [],\n    params\n  });\n\n  const value = useMemo(() => ({ state, dispatch }), [state, dispatch]);\n\n  //Get All Flags on Init\n  useEffect(() => {\n    let ignore = false;\n    //Get All the Flags\n    const onFetchFlags = async () => {\n      try {\n        //If the flags are collected, do not fetch again\n        if (state.flags.length > 0) return;\n\n        //Service Url\n        const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/flags`;\n\n        //Response with the all the flags\n        const response = await fetch(url);\n        const { flags } = await response.json();\n\n        //Filters flags a creates a simple array\n        const data = flags.map((item: { name: string }) => item.name);\n\n        //Updates the state with the flags\n        if (!ignore) {\n          dispatch({\n            type: \"set-flags\",\n            payload: {\n              flags: data,\n              loading: false\n            }\n          });\n          //Update or save on localStorage\n          await localForage.setItem(\"flags\", data);\n        }\n      } catch (e) {\n        dispatch({\n          type: \"set-flags-error\",\n          payload: { loading: false, error: true }\n        });\n      }\n    };\n    //Get All the Remote Flags\n    const onFetchRemotes = async () => {\n      try {\n        //If the Remotes Flags are collected, do not fetch again\n        if (state.remotes.length > 0) return;\n\n        //Service Url\n        const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/remotes`;\n\n        //Response with the all the remotes flags\n        const response = await fetch(url);\n        const { remotes } = await response.json();\n\n        //Updates the state with the remotes flags\n        if (!ignore) {\n          dispatch({\n            type: \"set-remotes\",\n            payload: { remotes, loading: false }\n          });\n          //Update or save on localStorage\n          await localForage.setItem(\"remotes\", remotes);\n        }\n      } catch (e) {\n        dispatch({\n          type: \"set-remotes-error\",\n          payload: { loading: false, error: true }\n        });\n      }\n    };\n    onFetchFlags();\n    onFetchRemotes();\n    return () => {\n      ignore = true;\n    };\n  }, []);\n\n  return (\n    <UpStampsContext.Provider value={value}>\n      {children}\n    </UpStampsContext.Provider>\n  );\n};\n","import { useContext } from \"react\";\nimport { UpStampsContext } from \"./Context\";\n\nconst useUpStampsContext = () => {\n  const context = useContext(UpStampsContext);\n  if (context === undefined) {\n    throw new Error(\"UpStampsContext must be used with UpStampsProvider!\");\n  }\n  return context;\n};\n\nexport default useUpStampsContext;\n","import { useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport const useFlag = (name: string) => {\n  const { state } = useUpstampsContext();\n  const flags = useMemo(() => state.flags, [state.flags]);\n\n  return {\n    show: flags.indexOf(name) !== -1,\n  } as const;\n};\n","import React, { Fragment, useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport interface FlagProps {\n  children: React.ReactNode;\n  name: string;\n}\n\nexport const Flag: React.FC<FlagProps> = ({ children, name }) => {\n  const { state } = useUpstampsContext();\n  const show = useMemo(() => state.flags.indexOf(name) !== -1, [\n    state.flags,\n    name,\n  ]);\n\n  //Hide the feature\n  if (!show) return null;\n\n  return <Fragment>{children}</Fragment>;\n};\n","import { useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport const useRemoteFlag = (name: string) => {\n  const { state } = useUpstampsContext();\n\n  const remote = useMemo(\n    () => state.remotes.filter((item: any) => item.name === name),\n    [state.remotes, name]\n  );\n  const verifyRemote = useMemo(() => remote.length > 0, [remote]);\n\n  return {\n    show: verifyRemote,\n    data: verifyRemote ? remote[0].data : {},\n  } as const;\n};\n","import React, { Fragment, useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport interface RemoteFlagProps {\n  children: any;\n  name: string;\n}\n\nexport const RemoteFlag: React.FC<RemoteFlagProps> = ({ children, name }) => {\n  const { state } = useUpstampsContext();\n\n  const remote = useMemo(\n    () => state.remotes.filter((item: any) => item.name === name),\n    [state.remotes, name]\n  );\n  const verifyRemote = useMemo(() => remote.length > 0, [remote]);\n  const data = verifyRemote ? remote[0].data : {};\n\n  //Hide the feature\n  if (!verifyRemote) return null;\n\n  return <Fragment>{children(data)}</Fragment>;\n};\n","export const variantTypes = [\"A\", \"B\"];\n\nexport const fetchHandler = async (url: string, name: string) => {\n  try {\n    //Response with the all the A/B Tests\n    const response = await fetch(url);\n    const { ABTesting } = await response.json();\n\n    const result = ABTesting.filter((item: any) => item.name === name);\n    const show = result.length > 0;\n    const randomVariant = Math.floor(Math.random() * variantTypes.length);\n\n    return {\n      show,\n      variant: variantTypes[randomVariant],\n      loading: false\n    };\n  } catch (e) {\n    throw e;\n  }\n};\n\nexport const emitterHandler = async (\n  variant: string,\n  name: string,\n  url: string\n) => {\n  try {\n    const post_body = {\n      name,\n      varA: variant === \"A\" ? 1 : 0,\n      varB: variant === \"B\" ? 1 : 0\n    };\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n      body: JSON.stringify(post_body)\n    });\n\n    return await response.json();\n  } catch (e) {\n    return e;\n  }\n};\n","import { useEffect, useState } from \"react\";\n//Context\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { fetchHandler, emitterHandler } from \"./shared\";\nimport localForage from \"localforage\";\n\ninterface IState {\n  loading: boolean;\n  error: boolean;\n  show: boolean;\n  variant: string;\n}\n\nexport const useABTest = (name: string, localStorage: boolean = false) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    loading: true,\n    error: false,\n    show: false,\n    variant: \"A\"\n  });\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/testing`;\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const storageData = (await localForage.getItem(name)) as IState;\n\n        //Checks the current data on local storage\n        if (localStorage && storageData !== null) {\n          console.log(\"useABTest local\");\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              ...storageData\n            };\n          });\n        } else {\n          console.log(\"useABTest remote\");\n          const { show, loading, variant } = await fetchHandler(url, name);\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              show,\n              variant,\n              loading\n            };\n          });\n          //Updates local storage with the new data\n          await localForage.setItem(name, {\n            show,\n            variant,\n            loading\n          });\n        }\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  const onEmitter = async () => {\n    try {\n      return await emitterHandler(state.variant, name, url);\n    } catch (e) {\n      return e;\n    }\n  };\n\n  return {\n    show: state.show,\n    error: state.error,\n    loading: state.loading,\n    variant: state.variant,\n    emitter: onEmitter\n  } as const;\n};\n","import React, { Fragment, useEffect, useState } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { fetchHandler, emitterHandler } from \"./shared\";\nimport localForage from \"localforage\";\n\nexport interface ABTestProps {\n  children: React.ReactNode;\n  testRef: React.RefObject<any>;\n  name: string;\n  localStorage?: boolean;\n}\n\ninterface IState {\n  component: React.ReactNode;\n  loading: boolean;\n  error: boolean;\n  variant: string;\n  show: boolean;\n}\n\ninterface ContainerProps {\n  children: React.ReactNode;\n  emitter: () => {};\n}\n\nconst Container = React.forwardRef(\n  (props: ContainerProps, ref: React.Ref<any>) => {\n    React.useImperativeHandle(ref, () => ({ emitter: props.emitter }));\n\n    return <Fragment>{props.children}</Fragment>;\n  }\n);\n\nexport const ABTest = ({\n  children,\n  name,\n  testRef,\n  localStorage = false\n}: ABTestProps) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    component: [],\n    loading: true,\n    error: false,\n    variant: \"A\",\n    show: false\n  });\n\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/testing`;\n\n  const onRenderChildren = (variant: string) => {\n    const component = React.Children.map(children, (child: any) => {\n      if (child.props.name === variant) {\n        return child;\n      }\n    });\n\n    setState((prevState: IState) => {\n      return {\n        ...prevState,\n        component\n      };\n    });\n  };\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const storageData = (await localForage.getItem(name)) as IState;\n\n        //Checks the current data on local storage\n        if (localStorage && storageData !== null) {\n          console.log(\"ABTest local\");\n          onRenderChildren(storageData.variant);\n\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              ...storageData\n            };\n          });\n        } else {\n          console.log(\"ABTest remote\");\n          const { show, loading, variant } = await fetchHandler(url, name);\n\n          onRenderChildren(variant);\n\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              show,\n              variant,\n              loading\n            };\n          });\n\n          //Updates local storage with the new data\n          await localForage.setItem(name, {\n            show,\n            variant,\n            loading\n          });\n        }\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  const onEmitter = async () => {\n    try {\n      return await emitterHandler(state.variant, name, url);\n    } catch (e) {\n      return e;\n    }\n  };\n\n  if (!state.loading && !state.show) return null;\n\n  return (\n    <Container ref={testRef} emitter={onEmitter}>\n      {state.component}\n    </Container>\n  );\n};\n\nconst Variant = ({\n  children,\n  name\n}: {\n  children: React.ReactNode;\n  name: string;\n}) => {\n  return React.cloneElement(\n    <Fragment />,\n    { name },\n    <Fragment>{children}</Fragment>\n  );\n};\n\nVariant.displayName = \"ABTest.Variant\";\n\nABTest.Variant = Variant;\n","export const queryBuilder = (params: {}) => {\n  const esc = encodeURIComponent;\n\n  return Object.keys(params)\n    .filter(\n      key => params[key] !== undefined && params[key] && params[key] !== null\n    )\n    .map(key => esc(key) + \"=\" + esc(params[key]))\n    .join(\"&\");\n};\n","//Utils\nimport { queryBuilder } from \"../Utils/functions\";\n\nexport const handleFetch = async (\n  url: string,\n  name: string,\n  params: { country?: string; client?: string; clientType?: string }\n) => {\n  try {\n    const query = queryBuilder({\n      name: name,\n      country: params.country,\n      client: params.client,\n      clientType: params.clientType\n    });\n\n    const response = await fetch(`${url}?${query}`, {\n      method: \"GET\"\n    });\n\n    const { segment } = await response.json();\n    const show = segment.length > 0;\n\n    return {\n      segment,\n      show,\n      loading: false\n    };\n  } catch (e) {\n    throw e;\n  }\n};\n","import { useState, useEffect } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { handleFetch } from \"./shared\";\nimport localForage from \"localforage\";\nimport isEqual from \"lodash.isequal\";\n\ninterface IState {\n  loading: boolean;\n  error: boolean;\n  show: boolean;\n}\n\ninterface Params {\n  country?: string;\n  client?: string;\n  clientType?: string;\n}\n\ninterface IStorageData extends IState {\n  params: Params;\n}\n\nexport const useSegment = (\n  name: string,\n  params: { country?: string; client?: string; clientType?: string },\n  localStorage: boolean = false\n) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    loading: true,\n    error: false,\n    show: false\n  });\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/segment`;\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const storageData = (await localForage.getItem(name)) as IStorageData;\n        //Checks the current data on local storage\n        if (localStorage && storageData !== null) {\n          console.log(\"useSegment local\");\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              show: isEqual(params, storageData.params),\n              loading: false\n            };\n          });\n        } else {\n          const { show, loading } = await handleFetch(url, name, params);\n          console.log(\"useSegment remote\");\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              show,\n              loading\n            };\n          });\n\n          //Updates local storage with the new data\n          await localForage.setItem(name, {\n            show,\n            loading,\n            params\n          });\n        }\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  return {\n    show: state.show,\n    error: state.error,\n    loading: state.loading\n  } as const;\n};\n","import React, { Fragment, useEffect, useState } from \"react\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { handleFetch } from \"./shared\";\nimport isEqual from \"lodash.isequal\";\n//Context\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//LocalStorage\nimport localForage from \"localforage\";\n\ninterface IState {\n  loading: boolean;\n  error: boolean;\n  show: boolean;\n}\n\ninterface Params {\n  country?: string;\n  client?: string;\n  clientType?: string;\n}\n\ninterface IStorageData extends IState {\n  params: Params;\n}\n\nexport interface SegmentProps extends Params {\n  children: React.ReactNode;\n  name: string;\n  params: Params;\n  localStorage?: boolean;\n}\n\nexport const Segment: React.FC<SegmentProps> = ({\n  children,\n  name,\n  params,\n  localStorage = false\n}) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    loading: true,\n    error: false,\n    show: false\n  });\n\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/segment`;\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const storageData = (await localForage.getItem(name)) as IStorageData;\n\n        //Checks the current data on local storage\n        if (localStorage && storageData !== null) {\n          console.log(\"Segment local = \");\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              show: isEqual(params, storageData.params),\n              loading: false\n            };\n          });\n        } else {\n          const { show, loading } = await handleFetch(url, name, params);\n          console.log(\"Segment remote\");\n          setState((prevState: IState) => {\n            return {\n              ...prevState,\n              show,\n              loading\n            };\n          });\n          //Updates local storage with the new data\n          await localForage.setItem(name, {\n            show,\n            loading,\n            params\n          });\n        }\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  //Hide the feature\n  if (!state.show) return null;\n\n  return <Fragment>{children}</Fragment>;\n};\n","import React, { createContext, useEffect, useReducer, useMemo } from \"react\";\n//Constants\nimport { apiUrl } from \"../Utils/constants\";\n//Contexts\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport interface ScopesConfigParams {\n  name?: string | null;\n  email: string;\n}\n\nexport interface ScopesState {\n  loading: boolean;\n  error: boolean;\n  params: ScopesConfigParams;\n}\n\nexport interface ScopesContextState {\n  state: ScopesState;\n}\n\nexport interface ScopesProviderProps extends ScopesConfigParams {\n  children: React.ReactNode;\n}\n\nexport type ReducerSetScope = {\n  type: \"set-scope\";\n  payload: {\n    success: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetScopeError = {\n  type: \"set-scope-error\";\n  payload: {\n    error: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerScopeActions = ReducerSetScope | ReducerSetScopeError;\n\nexport const ScopesContext = createContext<ScopesContextState>(\n  {} as ScopesContextState\n);\n\nlet reducer = (state: ScopesState, action: ReducerScopeActions) => {\n  switch (action.type) {\n    case \"set-scope\":\n      return { ...state, ...action.payload };\n    case \"set-scope-error\":\n      return { ...state, ...action.payload };\n\n    default:\n      throw new Error(`Unhandled action type`);\n  }\n};\n\nexport const ScopesProvider: React.FC<ScopesProviderProps> = ({\n  children,\n  name,\n  email\n}) => {\n  const context = useUpstampsContext();\n\n  const params = {\n    name,\n    email\n  };\n\n  const [state, dispatch] = useReducer(reducer, {\n    loading: true,\n    error: false,\n    params\n  });\n\n  const { clientId, projectKey } = context.state.params;\n\n  const value = useMemo(() => ({ state, dispatch }), [state, dispatch]);\n\n  useEffect(() => {\n    let ignore = false;\n    const onSetScope = async () => {\n      try {\n        //Service Url\n        const url = `${apiUrl}/${clientId}/${projectKey}/scopes/add`;\n\n        const post_body = {\n          name,\n          email\n        };\n\n        await fetch(url, {\n          method: \"POST\",\n          headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n          body: JSON.stringify(post_body)\n        });\n\n        window.localStorage.setItem(\"upstamps_scope_email\", email);\n\n        if (!ignore) {\n          dispatch({\n            type: \"set-scope\",\n            payload: { success: true, loading: false }\n          });\n        }\n      } catch (e) {\n        dispatch({\n          type: \"set-scope-error\",\n          payload: { loading: false, error: true }\n        });\n      }\n    };\n\n    //Get the email from localStorage\n    const storageEmail = window.localStorage.getItem(\"upstamps_scope_email\");\n\n    //Only set a scope if the email is null or different\n    if (storageEmail !== email) {\n      onSetScope();\n    }\n    return () => {\n      ignore = true;\n    };\n  }, [email]);\n\n  return (\n    <ScopesContext.Provider value={value}>{children}</ScopesContext.Provider>\n  );\n};\n"],"names":["apiUrl","UpStampsContext","createContext","reducer","state","action","type","payload","Error","UpStampsProvider","children","clientId","envKey","projectKey","params","useReducer","loading","error","flags","remotes","dispatch","value","useMemo","useEffect","ignore","onFetchFlags","length","url","fetch","response","json","data","map","item","name","localForage","setItem","onFetchRemotes","React","Provider","useUpStampsContext","context","useContext","undefined","useFlag","useUpstampsContext","show","indexOf","Flag","Fragment","useRemoteFlag","remote","filter","verifyRemote","RemoteFlag","variantTypes","fetchHandler","ABTesting","result","randomVariant","Math","floor","random","variant","e","emitterHandler","post_body","varA","varB","method","headers","body","JSON","stringify","useABTest","localStorage","useState","setState","onFetch","getItem","storageData","console","log","prevState","onEmitter","emitter","Container","forwardRef","props","ref","useImperativeHandle","ABTest","testRef","component","onRenderChildren","Children","child","Variant","cloneElement","displayName","queryBuilder","esc","encodeURIComponent","Object","keys","key","join","handleFetch","query","country","client","clientType","segment","useSegment","isEqual","Segment","ScopesContext","ScopesProvider","email","onSetScope","window","success","storageEmail"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AAmKA;AACO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AA4D/J;AACO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AA+UxL;AACA;AACO,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE;AACtC,CAAC,IAAI;AACL,EAAE,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;AACtB,EAAE,CAAC,MAAM,CAAC,EAAE;AACZ,EAAE,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;AACpB,EAAE;AACF,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC5B,EAAE,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;AACtC,EAAE;AACF,CAAC,OAAO,MAAM,CAAC;AACf;;AC5jBO,IAAMA,MAAM,GAAW,mCAAvB;;ICqEMC,eAAe;AAAA;AAAGC,aAAa,CAC1C,EAD0C,CAArC;;AAIP,IAAIC,OAAO,GAAG,SAAVA,OAAU,CAACC,KAAD,EAAuBC,MAAvB;AACZ,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,WAAL;AACE,0BAAYF,KAAZ,MAAsBC,MAAM,CAACE,OAA7B;;AACF,SAAK,iBAAL;AACE,0BAAYH,KAAZ,MAAsBC,MAAM,CAACE,OAA7B;;AACF,SAAK,aAAL;AACE,0BAAYH,KAAZ,MAAsBC,MAAM,CAACE,OAA7B;;AACF,SAAK,mBAAL;AACE,0BAAYH,KAAZ,MAAsBC,MAAM,CAACE,OAA7B;;AAEF;AACE,YAAM,IAAIC,KAAJ,yBAAN;AAXJ;AAaD,CAdD;;AAgBA,IAAaC,gBAAgB,GAAoC,SAApDA,gBAAoD;MAC/DC,gBAAAA;MACAC,gBAAAA;MACAC,cAAAA;MACAC,kBAAAA;AAEA,MAAMC,MAAM,GAAG;AACbH,IAAAA,QAAQ,EAARA,QADa;AAEbC,IAAAA,MAAM,EAANA,MAFa;AAGbC,IAAAA,UAAU,EAAVA;AAHa,GAAf;;oBAM0BE,UAAU,CAACZ,OAAD,EAAU;AAC5Ca,IAAAA,OAAO,EAAE,IADmC;AAE5CC,IAAAA,KAAK,EAAE,KAFqC;AAG5CC,IAAAA,KAAK,EAAE,EAHqC;AAI5CC,IAAAA,OAAO,EAAE,EAJmC;AAK5CL,IAAAA,MAAM,EAANA;AAL4C,GAAV;MAA7BV;MAAOgB;;AAQd,MAAMC,KAAK,GAAGC,OAAO,CAAC;AAAA,WAAO;AAAElB,MAAAA,KAAK,EAALA,KAAF;AAASgB,MAAAA,QAAQ,EAARA;AAAT,KAAP;AAAA,GAAD,EAA8B,CAAChB,KAAD,EAAQgB,QAAR,CAA9B,CAArB;;AAGAG,EAAAA,SAAS,CAAC;AACR,QAAIC,MAAM,GAAG,KAAb;;AAEA,QAAMC,YAAY,YAAZA,YAAY;AAAA;kDACZ;AACF;AACA,cAAIrB,KAAK,CAACc,KAAN,CAAYQ,MAAZ,GAAqB,CAAzB,EAA4B,OAF1B;;AAKF,cAAMC,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,SAA0CD,MAA1C,WAAT,CALE;;AAAA,iCAQqBgB,KAAK,CAACD,GAAD,CAR1B,iBAQIE,QARJ;AAAA,mCASsBA,QAAQ,CAACC,IAAT,EATtB;AAAA,kBASMZ,KATN,SASMA,KATN;AAWF;AACA,kBAAMa,IAAI,GAAGb,KAAK,CAACc,GAAN,CAAU,UAACC,IAAD;AAAA,uBAA4BA,IAAI,CAACC,IAAjC;AAAA,eAAV,CAAb,CAZE;;AAAA;AAAA,oBAeE,CAACV,MAfH;AAgBAJ,kBAAAA,QAAQ,CAAC;AACPd,oBAAAA,IAAI,EAAE,WADC;AAEPC,oBAAAA,OAAO,EAAE;AACPW,sBAAAA,KAAK,EAAEa,IADA;AAEPf,sBAAAA,OAAO,EAAE;AAFF;AAFF,mBAAD,CAAR,CAhBA;;AAAA,yCAwBMmB,WAAW,CAACC,OAAZ,CAAoB,OAApB,EAA6BL,IAA7B,CAxBN;AAAA;AAAA;;AAAA;AAAA;AAAA;AA0BH,uBAAW;AACVX,UAAAA,QAAQ,CAAC;AACPd,YAAAA,IAAI,EAAE,iBADC;AAEPC,YAAAA,OAAO,EAAE;AAAES,cAAAA,OAAO,EAAE,KAAX;AAAkBC,cAAAA,KAAK,EAAE;AAAzB;AAFF,WAAD,CAAR;AAID;AACF,OAjCiB;AAAA;AAAA;AAAA,KAAlB;;;AAmCA,QAAMoB,cAAc,YAAdA,cAAc;AAAA;kDACd;AACF;AACA,cAAIjC,KAAK,CAACe,OAAN,CAAcO,MAAd,GAAuB,CAA3B,EAA8B,OAF5B;;AAKF,cAAMC,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,SAA0CD,MAA1C,aAAT,CALE;;AAAA,iCAQqBgB,KAAK,CAACD,GAAD,CAR1B,iBAQIE,QARJ;AAAA,mCASwBA,QAAQ,CAACC,IAAT,EATxB;AAAA,kBASMX,OATN,SASMA,OATN;;AAAA;AAAA,oBAYE,CAACK,MAZH;AAaAJ,kBAAAA,QAAQ,CAAC;AACPd,oBAAAA,IAAI,EAAE,aADC;AAEPC,oBAAAA,OAAO,EAAE;AAAEY,sBAAAA,OAAO,EAAPA,OAAF;AAAWH,sBAAAA,OAAO,EAAE;AAApB;AAFF,mBAAD,CAAR,CAbA;;AAAA,yCAkBMmB,WAAW,CAACC,OAAZ,CAAoB,SAApB,EAA+BjB,OAA/B,CAlBN;AAAA;AAAA;;AAAA;AAAA;AAAA;AAoBH,uBAAW;AACVC,UAAAA,QAAQ,CAAC;AACPd,YAAAA,IAAI,EAAE,mBADC;AAEPC,YAAAA,OAAO,EAAE;AAAES,cAAAA,OAAO,EAAE,KAAX;AAAkBC,cAAAA,KAAK,EAAE;AAAzB;AAFF,WAAD,CAAR;AAID;AACF,OA3BmB;AAAA;AAAA;AAAA,KAApB;;AA4BAQ,IAAAA,YAAY;AACZY,IAAAA,cAAc;AACd,WAAO;AACLb,MAAAA,MAAM,GAAG,IAAT;AACD,KAFD;AAGD,GAvEQ,EAuEN,EAvEM,CAAT;AAyEA,SACEc,mBAAA,CAACrC,eAAe,CAACsC,QAAjB;AAA0BlB,IAAAA,KAAK,EAAEA;GAAjC,EACGX,QADH,CADF;AAKD,CArGM;;ACtFP,IAAM8B,kBAAkB,GAAG,SAArBA,kBAAqB;AACzB,MAAMC,OAAO,GAAGC,UAAU,CAACzC,eAAD,CAA1B;;AACA,MAAIwC,OAAO,KAAKE,SAAhB,EAA2B;AACzB,UAAM,IAAInC,KAAJ,CAAU,qDAAV,CAAN;AACD;;AACD,SAAOiC,OAAP;AACD,CAND;;ICAaG,OAAO,GAAG,SAAVA,OAAU,CAACV,IAAD;4BACHW,kBAAkB;MAA5BzC,4BAAAA;;AACR,MAAMc,KAAK,GAAGI,OAAO,CAAC;AAAA,WAAMlB,KAAK,CAACc,KAAZ;AAAA,GAAD,EAAoB,CAACd,KAAK,CAACc,KAAP,CAApB,CAArB;AAEA,SAAO;AACL4B,IAAAA,IAAI,EAAE5B,KAAK,CAAC6B,OAAN,CAAcb,IAAd,MAAwB,CAAC;AAD1B,GAAP;AAGD,CAPM;;ICKMc,IAAI,GAAwB,SAA5BA,IAA4B;MAAGtC,gBAAAA;MAAUwB,YAAAA;;4BAClCW,kBAAkB;MAA5BzC,4BAAAA;;AACR,MAAM0C,IAAI,GAAGxB,OAAO,CAAC;AAAA,WAAMlB,KAAK,CAACc,KAAN,CAAY6B,OAAZ,CAAoBb,IAApB,MAA8B,CAAC,CAArC;AAAA,GAAD,EAAyC,CAC3D9B,KAAK,CAACc,KADqD,EAE3DgB,IAF2D,CAAzC,CAApB;;AAMA,MAAI,CAACY,IAAL,EAAW,OAAO,IAAP;AAEX,SAAOR,mBAAA,CAACW,QAAD,MAAA,EAAWvC,QAAX,CAAP;AACD,CAXM;;ICLMwC,aAAa,GAAG,SAAhBA,aAAgB,CAAChB,IAAD;4BACTW,kBAAkB;MAA5BzC,4BAAAA;;AAER,MAAM+C,MAAM,GAAG7B,OAAO,CACpB;AAAA,WAAMlB,KAAK,CAACe,OAAN,CAAciC,MAAd,CAAqB,UAACnB,IAAD;AAAA,aAAeA,IAAI,CAACC,IAAL,KAAcA,IAA7B;AAAA,KAArB,CAAN;AAAA,GADoB,EAEpB,CAAC9B,KAAK,CAACe,OAAP,EAAgBe,IAAhB,CAFoB,CAAtB;AAIA,MAAMmB,YAAY,GAAG/B,OAAO,CAAC;AAAA,WAAM6B,MAAM,CAACzB,MAAP,GAAgB,CAAtB;AAAA,GAAD,EAA0B,CAACyB,MAAD,CAA1B,CAA5B;AAEA,SAAO;AACLL,IAAAA,IAAI,EAAEO,YADD;AAELtB,IAAAA,IAAI,EAAEsB,YAAY,GAAGF,MAAM,CAAC,CAAD,CAAN,CAAUpB,IAAb,GAAoB;AAFjC,GAAP;AAID,CAbM;;ICKMuB,UAAU,GAA8B,SAAxCA,UAAwC;MAAG5C,gBAAAA;MAAUwB,YAAAA;;4BAC9CW,kBAAkB;MAA5BzC,4BAAAA;;AAER,MAAM+C,MAAM,GAAG7B,OAAO,CACpB;AAAA,WAAMlB,KAAK,CAACe,OAAN,CAAciC,MAAd,CAAqB,UAACnB,IAAD;AAAA,aAAeA,IAAI,CAACC,IAAL,KAAcA,IAA7B;AAAA,KAArB,CAAN;AAAA,GADoB,EAEpB,CAAC9B,KAAK,CAACe,OAAP,EAAgBe,IAAhB,CAFoB,CAAtB;AAIA,MAAMmB,YAAY,GAAG/B,OAAO,CAAC;AAAA,WAAM6B,MAAM,CAACzB,MAAP,GAAgB,CAAtB;AAAA,GAAD,EAA0B,CAACyB,MAAD,CAA1B,CAA5B;AACA,MAAMpB,IAAI,GAAGsB,YAAY,GAAGF,MAAM,CAAC,CAAD,CAAN,CAAUpB,IAAb,GAAoB,EAA7C;;AAGA,MAAI,CAACsB,YAAL,EAAmB,OAAO,IAAP;AAEnB,SAAOf,mBAAA,CAACW,QAAD,MAAA,EAAWvC,QAAQ,CAACqB,IAAD,CAAnB,CAAP;AACD,CAdM;;ACRA,IAAMwB,YAAY,GAAG,CAAC,GAAD,EAAM,GAAN,CAArB;AAEP,AAAO,IAAMC,YAAY,YAAZA,YAAY,CAAU7B,GAAV,EAAuBO,IAAvB;AAAA;8CACnB;AACF;AADE,6BAEqBN,KAAK,CAACD,GAAD,CAF1B,iBAEIE,QAFJ;AAAA,+BAG0BA,QAAQ,CAACC,IAAT,EAH1B;AAAA,cAGM2B,SAHN,QAGMA,SAHN;AAKF,cAAMC,MAAM,GAAGD,SAAS,CAACL,MAAV,CAAiB,UAACnB,IAAD;AAAA,mBAAeA,IAAI,CAACC,IAAL,KAAcA,IAA7B;AAAA,WAAjB,CAAf;AACA,cAAMY,IAAI,GAAGY,MAAM,CAAChC,MAAP,GAAgB,CAA7B;AACA,cAAMiC,aAAa,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBP,YAAY,CAAC7B,MAAxC,CAAtB;AAEA,iBAAO;AACLoB,YAAAA,IAAI,EAAJA,IADK;AAELiB,YAAAA,OAAO,EAAER,YAAY,CAACI,aAAD,CAFhB;AAGL3C,YAAAA,OAAO,EAAE;AAHJ,WAAP;AATE;AAAA;AAcH,iBAAQgD,GAAG;AACV,YAAMA,CAAN;AACD;AACF,GAlBwB;AAAA;AAAA;AAAA,CAAlB;AAoBP,AAAO,IAAMC,cAAc,YAAdA,cAAc,CACzBF,OADyB,EAEzB7B,IAFyB,EAGzBP,GAHyB;4CAKrB;AACF,QAAMuC,SAAS,GAAG;AAChBhC,MAAAA,IAAI,EAAJA,IADgB;AAEhBiC,MAAAA,IAAI,EAAEJ,OAAO,KAAK,GAAZ,GAAkB,CAAlB,GAAsB,CAFZ;AAGhBK,MAAAA,IAAI,EAAEL,OAAO,KAAK,GAAZ,GAAkB,CAAlB,GAAsB;AAHZ,KAAlB;AADE,2BAOqBnC,KAAK,CAACD,GAAD,EAAM;AAChC0C,MAAAA,MAAM,EAAE,MADwB;AAEhCC,MAAAA,OAAO,EAAE;AAAE,wBAAgB;AAAlB,OAFuB;AAGhCC,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeP,SAAf;AAH0B,KAAN,CAP1B,iBAOIrC,QAPJ;AAAA,6BAaWA,QAAQ,CAACC,IAAT,EAbX;AAAA;AAcH,eAAQkC,GAAG;AACV,WAAOA,CAAP;AACD;AACF,CAtBM;;ICPMU,SAAS,GAAG,SAAZA,SAAY,CAACxC,IAAD,EAAeyC,YAAf;MAAeA;AAAAA,IAAAA,eAAwB;;;AAC9D,MAAMlC,OAAO,GAAGI,kBAAkB,EAAlC;;kBAC0B+B,QAAQ,CAAS;AACzC5D,IAAAA,OAAO,EAAE,IADgC;AAEzCC,IAAAA,KAAK,EAAE,KAFkC;AAGzC6B,IAAAA,IAAI,EAAE,KAHmC;AAIzCiB,IAAAA,OAAO,EAAE;AAJgC,GAAT;MAA3B3D;MAAOyE;;8BAM2BpC,OAAO,CAACrC,KAAR,CAAcU;MAA/CH,iCAAAA;MAAUE,mCAAAA;MAAYD,+BAAAA;AAC9B,MAAMe,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,SAA0CD,MAA1C,aAAT;AAEAW,EAAAA,SAAS,CAAC;AACR,QAAMuD,OAAO,YAAPA,OAAO;AAAA;wCACP;AAAA,iCACyB3C,WAAW,CAAC4C,OAAZ,CAAoB7C,IAApB,CADzB,iBACI8C,WADJ;AAAA;AAAA,kBAIEL,YAAY,IAAIK,WAAW,KAAK,IAJlC;AAKAC,gBAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACAL,gBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,sCACKA,SADL,MAEKH,WAFL;AAID,iBALO,CAAR;AANA;AAaAC,gBAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AAbA,uCAcyC1B,YAAY,CAAC7B,GAAD,EAAMO,IAAN,CAdrD;AAAA,sBAcQY,IAdR,QAcQA,IAdR;AAAA,sBAcc9B,OAdd,QAccA,OAdd;AAAA,sBAcuB+C,OAdvB,QAcuBA,OAdvB;AAeAc,kBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,wCACKA,SADL;AAEErC,sBAAAA,IAAI,EAAJA,IAFF;AAGEiB,sBAAAA,OAAO,EAAPA,OAHF;AAIE/C,sBAAAA,OAAO,EAAPA;AAJF;AAMD,mBAPO,CAAR,CAfA;;AAAA,yCAwBMmB,WAAW,CAACC,OAAZ,CAAoBF,IAApB,EAA0B;AAC9BY,oBAAAA,IAAI,EAAJA,IAD8B;AAE9BiB,oBAAAA,OAAO,EAAPA,OAF8B;AAG9B/C,oBAAAA,OAAO,EAAPA;AAH8B,mBAA1B,CAxBN;AAAA;AAAA;AAAA;;AAAA;AAAA;AA8BH,uBAAW;AACV6D,UAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,gCAAYA,SAAZ;AAAuBlE,cAAAA,KAAK,EAAE,IAA9B;AAAoCD,cAAAA,OAAO,EAAE;AAA7C;AACD,WAFO,CAAR;AAGD;;;AACF,OApCY;AAAA;AAAA;AAAA,KAAb;;AAqCA8D,IAAAA,OAAO;AACR,GAvCQ,EAuCN,CAAC5C,IAAD,EAAOO,OAAO,CAACrC,KAAR,CAAcU,MAArB,CAvCM,CAAT;;AAyCA,MAAMsE,SAAS,YAATA,SAAS;8CACT;AAAA,6BACWnB,cAAc,CAAC7D,KAAK,CAAC2D,OAAP,EAAgB7B,IAAhB,EAAsBP,GAAtB,CADzB;AAEH,iBAAQqC,GAAG;AACV,aAAOA,CAAP;AACD;AACF,GAND;;AAQA,SAAO;AACLlB,IAAAA,IAAI,EAAE1C,KAAK,CAAC0C,IADP;AAEL7B,IAAAA,KAAK,EAAEb,KAAK,CAACa,KAFR;AAGLD,IAAAA,OAAO,EAAEZ,KAAK,CAACY,OAHV;AAIL+C,IAAAA,OAAO,EAAE3D,KAAK,CAAC2D,OAJV;AAKLsB,IAAAA,OAAO,EAAED;AALJ,GAAP;AAOD,CAnEM;;ACYP,IAAME,SAAS;AAAA;AAAGhD,KAAK,CAACiD,UAAN,CAChB,UAACC,KAAD,EAAwBC,GAAxB;AACEnD,EAAAA,KAAK,CAACoD,mBAAN,CAA0BD,GAA1B,EAA+B;AAAA,WAAO;AAAEJ,MAAAA,OAAO,EAAEG,KAAK,CAACH;AAAjB,KAAP;AAAA,GAA/B;AAEA,SAAO/C,mBAAA,CAACW,QAAD,MAAA,EAAWuC,KAAK,CAAC9E,QAAjB,CAAP;AACD,CALe,CAAlB;AAQA,IAAaiF,MAAM,GAAG,SAATA,MAAS;MACpBjF,gBAAAA;MACAwB,YAAAA;MACA0D,eAAAA;+BACAjB;MAAAA,8CAAe;AAEf,MAAMlC,OAAO,GAAGI,kBAAkB,EAAlC;;kBAC0B+B,QAAQ,CAAS;AACzCiB,IAAAA,SAAS,EAAE,EAD8B;AAEzC7E,IAAAA,OAAO,EAAE,IAFgC;AAGzCC,IAAAA,KAAK,EAAE,KAHkC;AAIzC8C,IAAAA,OAAO,EAAE,GAJgC;AAKzCjB,IAAAA,IAAI,EAAE;AALmC,GAAT;MAA3B1C;MAAOyE;;8BAQ2BpC,OAAO,CAACrC,KAAR,CAAcU;MAA/CH,iCAAAA;MAAUE,mCAAAA;MAAYD,+BAAAA;AAC9B,MAAMe,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,SAA0CD,MAA1C,aAAT;;AAEA,MAAMkF,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAC/B,OAAD;AACvB,QAAM8B,SAAS,GAAGvD,KAAK,CAACyD,QAAN,CAAe/D,GAAf,CAAmBtB,QAAnB,EAA6B,UAACsF,KAAD;AAC7C,UAAIA,KAAK,CAACR,KAAN,CAAYtD,IAAZ,KAAqB6B,OAAzB,EAAkC;AAChC,eAAOiC,KAAP;AACD;AACF,KAJiB,CAAlB;AAMAnB,IAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,0BACKA,SADL;AAEEU,QAAAA,SAAS,EAATA;AAFF;AAID,KALO,CAAR;AAMD,GAbD;;AAeAtE,EAAAA,SAAS,CAAC;AACR,QAAMuD,OAAO,YAAPA,OAAO;AAAA;wCACP;AAAA,iCACyB3C,WAAW,CAAC4C,OAAZ,CAAoB7C,IAApB,CADzB,iBACI8C,WADJ;AAAA;AAAA,kBAIEL,YAAY,IAAIK,WAAW,KAAK,IAJlC;AAKAC,gBAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACAY,gBAAAA,gBAAgB,CAACd,WAAW,CAACjB,OAAb,CAAhB;AAEAc,gBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,sCACKA,SADL,MAEKH,WAFL;AAID,iBALO,CAAR;AARA;AAeAC,gBAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ;AAfA,uCAgByC1B,YAAY,CAAC7B,GAAD,EAAMO,IAAN,CAhBrD;AAAA,sBAgBQY,IAhBR,SAgBQA,IAhBR;AAAA,sBAgBc9B,OAhBd,SAgBcA,OAhBd;AAAA,sBAgBuB+C,OAhBvB,SAgBuBA,OAhBvB;AAkBA+B,kBAAAA,gBAAgB,CAAC/B,OAAD,CAAhB;AAEAc,kBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,wCACKA,SADL;AAEErC,sBAAAA,IAAI,EAAJA,IAFF;AAGEiB,sBAAAA,OAAO,EAAPA,OAHF;AAIE/C,sBAAAA,OAAO,EAAPA;AAJF;AAMD,mBAPO,CAAR,CApBA;;AAAA,yCA8BMmB,WAAW,CAACC,OAAZ,CAAoBF,IAApB,EAA0B;AAC9BY,oBAAAA,IAAI,EAAJA,IAD8B;AAE9BiB,oBAAAA,OAAO,EAAPA,OAF8B;AAG9B/C,oBAAAA,OAAO,EAAPA;AAH8B,mBAA1B,CA9BN;AAAA;AAAA;AAAA;;AAAA;AAAA;AAoCH,uBAAW;AACV6D,UAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,gCAAYA,SAAZ;AAAuBlE,cAAAA,KAAK,EAAE,IAA9B;AAAoCD,cAAAA,OAAO,EAAE;AAA7C;AACD,WAFO,CAAR;AAGD;;;AACF,OA1CY;AAAA;AAAA;AAAA,KAAb;;AA2CA8D,IAAAA,OAAO;AACR,GA7CQ,EA6CN,CAAC5C,IAAD,EAAOO,OAAO,CAACrC,KAAR,CAAcU,MAArB,CA7CM,CAAT;;AA+CA,MAAMsE,SAAS,YAATA,SAAS;8CACT;AAAA,6BACWnB,cAAc,CAAC7D,KAAK,CAAC2D,OAAP,EAAgB7B,IAAhB,EAAsBP,GAAtB,CADzB;AAEH,iBAAQqC,GAAG;AACV,aAAOA,CAAP;AACD;AACF,GAND;;AAQA,MAAI,CAAC5D,KAAK,CAACY,OAAP,IAAkB,CAACZ,KAAK,CAAC0C,IAA7B,EAAmC,OAAO,IAAP;AAEnC,SACER,mBAAA,CAACgD,SAAD;AAAWG,IAAAA,GAAG,EAAEG;AAASP,IAAAA,OAAO,EAAED;GAAlC,EACGhF,KAAK,CAACyF,SADT,CADF;AAKD,CA/FM;;AAiGP,IAAMI,OAAO,GAAG,SAAVA,OAAU;MACdvF,iBAAAA;MACAwB,aAAAA;AAKA,SAAOI,KAAK,CAAC4D,YAAN,CACL5D,mBAAA,CAACW,QAAD,MAAA,CADK,EAEL;AAAEf,IAAAA,IAAI,EAAJA;AAAF,GAFK,EAGLI,mBAAA,CAACW,QAAD,MAAA,EAAWvC,QAAX,CAHK,CAAP;AAKD,CAZD;;AAcAuF,OAAO,CAACE,WAAR,GAAsB,gBAAtB;AAEAR,MAAM,CAACM,OAAP,GAAiBA,OAAjB;;ACpJO,IAAMG,YAAY,GAAG,SAAfA,YAAe,CAACtF,MAAD;AAC1B,MAAMuF,GAAG,GAAGC,kBAAZ;AAEA,SAAOC,MAAM,CAACC,IAAP,CAAY1F,MAAZ,EACJsC,MADI,CAEH,UAAAqD,GAAG;AAAA,WAAI3F,MAAM,CAAC2F,GAAD,CAAN,KAAgB9D,SAAhB,IAA6B7B,MAAM,CAAC2F,GAAD,CAAnC,IAA4C3F,MAAM,CAAC2F,GAAD,CAAN,KAAgB,IAAhE;AAAA,GAFA,EAIJzE,GAJI,CAIA,UAAAyE,GAAG;AAAA,WAAIJ,GAAG,CAACI,GAAD,CAAH,GAAW,GAAX,GAAiBJ,GAAG,CAACvF,MAAM,CAAC2F,GAAD,CAAP,CAAxB;AAAA,GAJH,EAKJC,IALI,CAKC,GALD,CAAP;AAMD,CATM;;ACGA,IAAMC,WAAW,YAAXA,WAAW,CACtBhF,GADsB,EAEtBO,IAFsB,EAGtBpB,MAHsB;AAAA;8CAKlB;AACF,UAAM8F,KAAK,GAAGR,YAAY,CAAC;AACzBlE,QAAAA,IAAI,EAAEA,IADmB;AAEzB2E,QAAAA,OAAO,EAAE/F,MAAM,CAAC+F,OAFS;AAGzBC,QAAAA,MAAM,EAAEhG,MAAM,CAACgG,MAHU;AAIzBC,QAAAA,UAAU,EAAEjG,MAAM,CAACiG;AAJM,OAAD,CAA1B;AADE,6BAQqBnF,KAAK,CAAID,GAAJ,SAAWiF,KAAX,EAAoB;AAC9CvC,QAAAA,MAAM,EAAE;AADsC,OAApB,CAR1B,iBAQIxC,QARJ;AAAA,+BAYwBA,QAAQ,CAACC,IAAT,EAZxB;AAAA,cAYMkF,OAZN,QAYMA,OAZN;AAaF,cAAMlE,IAAI,GAAGkE,OAAO,CAACtF,MAAR,GAAiB,CAA9B;AAEA,iBAAO;AACLsF,YAAAA,OAAO,EAAPA,OADK;AAELlE,YAAAA,IAAI,EAAJA,IAFK;AAGL9B,YAAAA,OAAO,EAAE;AAHJ,WAAP;AAfE;AAAA;AAoBH,iBAAQgD,GAAG;AACV,YAAMA,CAAN;AACD;AACF,GA5BuB;AAAA;AAAA;AAAA,CAAjB;;ICqBMiD,UAAU,GAAG,SAAbA,UAAa,CACxB/E,IADwB,EAExBpB,MAFwB,EAGxB6D,YAHwB;MAGxBA;AAAAA,IAAAA,eAAwB;;;AAExB,MAAMlC,OAAO,GAAGI,kBAAkB,EAAlC;;kBAC0B+B,QAAQ,CAAS;AACzC5D,IAAAA,OAAO,EAAE,IADgC;AAEzCC,IAAAA,KAAK,EAAE,KAFkC;AAGzC6B,IAAAA,IAAI,EAAE;AAHmC,GAAT;MAA3B1C;MAAOyE;;8BAK2BpC,OAAO,CAACrC,KAAR,CAAcU;MAA/CH,iCAAAA;MAAUE,mCAAAA;MAAYD,+BAAAA;AAC9B,MAAMe,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,SAA0CD,MAA1C,aAAT;AAEAW,EAAAA,SAAS,CAAC;AACR,QAAMuD,OAAO,YAAPA,OAAO;AAAA;wCACP;AAAA,iCACyB3C,WAAW,CAAC4C,OAAZ,CAAoB7C,IAApB,CADzB,iBACI8C,WADJ;AAAA;AAAA,kBAGEL,YAAY,IAAIK,WAAW,KAAK,IAHlC;AAIAC,gBAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACAL,gBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,sCACKA,SADL;AAEErC,oBAAAA,IAAI,EAAEoE,OAAO,CAACpG,MAAD,EAASkE,WAAW,CAAClE,MAArB,CAFf;AAGEE,oBAAAA,OAAO,EAAE;AAHX;AAKD,iBANO,CAAR;AALA;AAAA,uCAagC2F,WAAW,CAAChF,GAAD,EAAMO,IAAN,EAAYpB,MAAZ,CAb3C;AAAA,sBAaQgC,IAbR,QAaQA,IAbR;AAAA,sBAac9B,OAbd,QAacA,OAbd;AAcAiE,kBAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ;AACAL,kBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,wCACKA,SADL;AAEErC,sBAAAA,IAAI,EAAJA,IAFF;AAGE9B,sBAAAA,OAAO,EAAPA;AAHF;AAKD,mBANO,CAAR,CAfA;;AAAA,yCAwBMmB,WAAW,CAACC,OAAZ,CAAoBF,IAApB,EAA0B;AAC9BY,oBAAAA,IAAI,EAAJA,IAD8B;AAE9B9B,oBAAAA,OAAO,EAAPA,OAF8B;AAG9BF,oBAAAA,MAAM,EAANA;AAH8B,mBAA1B,CAxBN;AAAA;AAAA;AAAA;;AAAA;AAAA;AA8BH,uBAAW;AACV+D,UAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,gCAAYA,SAAZ;AAAuBlE,cAAAA,KAAK,EAAE,IAA9B;AAAoCD,cAAAA,OAAO,EAAE;AAA7C;AACD,WAFO,CAAR;AAGD;;;AACF,OApCY;AAAA;AAAA;AAAA,KAAb;;AAqCA8D,IAAAA,OAAO;AACR,GAvCQ,EAuCN,CAAC5C,IAAD,EAAOO,OAAO,CAACrC,KAAR,CAAcU,MAArB,CAvCM,CAAT;AAyCA,SAAO;AACLgC,IAAAA,IAAI,EAAE1C,KAAK,CAAC0C,IADP;AAEL7B,IAAAA,KAAK,EAAEb,KAAK,CAACa,KAFR;AAGLD,IAAAA,OAAO,EAAEZ,KAAK,CAACY;AAHV,GAAP;AAKD,CA5DM;;ICSMmG,OAAO,GAA2B,SAAlCA,OAAkC;MAC7CzG,gBAAAA;MACAwB,YAAAA;MACApB,cAAAA;+BACA6D;MAAAA,8CAAe;AAEf,MAAMlC,OAAO,GAAGI,kBAAkB,EAAlC;;kBAC0B+B,QAAQ,CAAS;AACzC5D,IAAAA,OAAO,EAAE,IADgC;AAEzCC,IAAAA,KAAK,EAAE,KAFkC;AAGzC6B,IAAAA,IAAI,EAAE;AAHmC,GAAT;MAA3B1C;MAAOyE;;8BAM2BpC,OAAO,CAACrC,KAAR,CAAcU;MAA/CH,iCAAAA;MAAUE,mCAAAA;MAAYD,+BAAAA;AAC9B,MAAMe,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,SAA0CD,MAA1C,aAAT;AAEAW,EAAAA,SAAS,CAAC;AACR,QAAMuD,OAAO,YAAPA,OAAO;AAAA;wCACP;AAAA,iCACyB3C,WAAW,CAAC4C,OAAZ,CAAoB7C,IAApB,CADzB,iBACI8C,WADJ;AAAA;AAAA,kBAIEL,YAAY,IAAIK,WAAW,KAAK,IAJlC;AAKAC,gBAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACAL,gBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,sCACKA,SADL;AAEErC,oBAAAA,IAAI,EAAEoE,OAAO,CAACpG,MAAD,EAASkE,WAAW,CAAClE,MAArB,CAFf;AAGEE,oBAAAA,OAAO,EAAE;AAHX;AAKD,iBANO,CAAR;AANA;AAAA,uCAcgC2F,WAAW,CAAChF,GAAD,EAAMO,IAAN,EAAYpB,MAAZ,CAd3C;AAAA,sBAcQgC,IAdR,SAcQA,IAdR;AAAA,sBAcc9B,OAdd,SAccA,OAdd;AAeAiE,kBAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACAL,kBAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,wCACKA,SADL;AAEErC,sBAAAA,IAAI,EAAJA,IAFF;AAGE9B,sBAAAA,OAAO,EAAPA;AAHF;AAKD,mBANO,CAAR,CAhBA;;AAAA,yCAwBMmB,WAAW,CAACC,OAAZ,CAAoBF,IAApB,EAA0B;AAC9BY,oBAAAA,IAAI,EAAJA,IAD8B;AAE9B9B,oBAAAA,OAAO,EAAPA,OAF8B;AAG9BF,oBAAAA,MAAM,EAANA;AAH8B,mBAA1B,CAxBN;AAAA;AAAA;AAAA;;AAAA;AAAA;AA8BH,uBAAW;AACV+D,UAAAA,QAAQ,CAAC,UAACM,SAAD;AACP,gCAAYA,SAAZ;AAAuBlE,cAAAA,KAAK,EAAE,IAA9B;AAAoCD,cAAAA,OAAO,EAAE;AAA7C;AACD,WAFO,CAAR;AAGD;;;AACF,OApCY;AAAA;AAAA;AAAA,KAAb;;AAqCA8D,IAAAA,OAAO;AACR,GAvCQ,EAuCN,CAAC5C,IAAD,EAAOO,OAAO,CAACrC,KAAR,CAAcU,MAArB,CAvCM,CAAT;;AA0CA,MAAI,CAACV,KAAK,CAAC0C,IAAX,EAAiB,OAAO,IAAP;AAEjB,SAAOR,mBAAA,CAACW,QAAD,MAAA,EAAWvC,QAAX,CAAP;AACD,CA7DM;;ICUM0G,aAAa;AAAA;AAAGlH,aAAa,CACxC,EADwC,CAAnC;;AAIP,IAAIC,SAAO,GAAG,SAAVA,OAAU,CAACC,KAAD,EAAqBC,MAArB;AACZ,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,WAAL;AACE,0BAAYF,KAAZ,MAAsBC,MAAM,CAACE,OAA7B;;AACF,SAAK,iBAAL;AACE,0BAAYH,KAAZ,MAAsBC,MAAM,CAACE,OAA7B;;AAEF;AACE,YAAM,IAAIC,KAAJ,yBAAN;AAPJ;AASD,CAVD;;AAYA,IAAa6G,cAAc,GAAkC,SAAhDA,cAAgD;MAC3D3G,gBAAAA;MACAwB,YAAAA;MACAoF,aAAAA;AAEA,MAAM7E,OAAO,GAAGI,kBAAkB,EAAlC;AAEA,MAAM/B,MAAM,GAAG;AACboB,IAAAA,IAAI,EAAJA,IADa;AAEboF,IAAAA,KAAK,EAALA;AAFa,GAAf;;oBAK0BvG,UAAU,CAACZ,SAAD,EAAU;AAC5Ca,IAAAA,OAAO,EAAE,IADmC;AAE5CC,IAAAA,KAAK,EAAE,KAFqC;AAG5CH,IAAAA,MAAM,EAANA;AAH4C,GAAV;MAA7BV;MAAOgB;;8BAMmBqB,OAAO,CAACrC,KAAR,CAAcU;MAAvCH,iCAAAA;MAAUE,mCAAAA;AAElB,MAAMQ,KAAK,GAAGC,OAAO,CAAC;AAAA,WAAO;AAAElB,MAAAA,KAAK,EAALA,KAAF;AAASgB,MAAAA,QAAQ,EAARA;AAAT,KAAP;AAAA,GAAD,EAA8B,CAAChB,KAAD,EAAQgB,QAAR,CAA9B,CAArB;AAEAG,EAAAA,SAAS,CAAC;AACR,QAAIC,MAAM,GAAG,KAAb;;AACA,QAAM+F,UAAU,YAAVA,UAAU;AAAA;wCACV;AACF;AACA,cAAM5F,GAAG,GAAM3B,MAAN,SAAgBW,QAAhB,SAA4BE,UAA5B,gBAAT;AAEA,cAAMqD,SAAS,GAAG;AAChBhC,YAAAA,IAAI,EAAJA,IADgB;AAEhBoF,YAAAA,KAAK,EAALA;AAFgB,WAAlB;AAJE,iCASI1F,KAAK,CAACD,GAAD,EAAM;AACf0C,YAAAA,MAAM,EAAE,MADO;AAEfC,YAAAA,OAAO,EAAE;AAAE,8BAAgB;AAAlB,aAFM;AAGfC,YAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAeP,SAAf;AAHS,WAAN,CATT;AAeFsD,YAAAA,MAAM,CAAC7C,YAAP,CAAoBvC,OAApB,CAA4B,sBAA5B,EAAoDkF,KAApD;;AAfE,gBAiBE,CAAC9F,MAjBH;AAkBAJ,cAAAA,QAAQ,CAAC;AACPd,gBAAAA,IAAI,EAAE,WADC;AAEPC,gBAAAA,OAAO,EAAE;AAAEkH,kBAAAA,OAAO,EAAE,IAAX;AAAiBzG,kBAAAA,OAAO,EAAE;AAA1B;AAFF,eAAD,CAAR;AAlBA;AAAA;AAuBH,uBAAW;AACVI,UAAAA,QAAQ,CAAC;AACPd,YAAAA,IAAI,EAAE,iBADC;AAEPC,YAAAA,OAAO,EAAE;AAAES,cAAAA,OAAO,EAAE,KAAX;AAAkBC,cAAAA,KAAK,EAAE;AAAzB;AAFF,WAAD,CAAR;AAID;;;AACF,OA9Be;AAAA;AAAA;AAAA,KAAhB;;;AAiCA,QAAMyG,YAAY,GAAGF,MAAM,CAAC7C,YAAP,CAAoBI,OAApB,CAA4B,sBAA5B,CAArB;;AAGA,QAAI2C,YAAY,KAAKJ,KAArB,EAA4B;AAC1BC,MAAAA,UAAU;AACX;;AACD,WAAO;AACL/F,MAAAA,MAAM,GAAG,IAAT;AACD,KAFD;AAGD,GA5CQ,EA4CN,CAAC8F,KAAD,CA5CM,CAAT;AA8CA,SACEhF,mBAAA,CAAC8E,aAAa,CAAC7E,QAAf;AAAwBlB,IAAAA,KAAK,EAAEA;GAA/B,EAAuCX,QAAvC,CADF;AAGD,CAvEM;;;;"}