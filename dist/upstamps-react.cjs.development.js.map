{"version":3,"file":"upstamps-react.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Utils/constants.ts","../src/Contexts/Context.tsx","../src/Contexts/useUpstampsContext.tsx","../src/Flags/useFlag.tsx","../src/Flags/Flag.tsx","../src/Remotes/useRemoteFlag.tsx","../src/Remotes/RemoteFlag.tsx","../src/ABTests/shared.ts","../src/ABTests/useABTest.tsx","../src/ABTests/ABTest.tsx","../src/Utils/functions.ts","../src/Segments/shared.ts","../src/Segments/useSegment.tsx","../src/Segments/Segment.tsx","../src/Scopes/ScopeContext.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export const apiUrl: string = \"https://services.upstamps.com/api\";\n","import React, { createContext, useEffect, useReducer, useMemo } from \"react\";\n//Constants\nimport { apiUrl } from \"../Utils/constants\";\n\nexport interface UpStampsConfigParams {\n  clientId: string;\n  envKey: string;\n  projectKey: string;\n}\n\nexport interface UpStampsState {\n  loading: boolean;\n  error: boolean;\n  flags: Array<string>;\n  remotes: Array<{ name: string; data: {} }>;\n  params: UpStampsConfigParams;\n}\n\nexport interface UpStampsContextState {\n  state: UpStampsState;\n}\n\nexport interface UpStampsProviderProps extends UpStampsConfigParams {\n  children: React.ReactNode;\n}\n\nexport type ReducerSetFlags = {\n  type: \"set-flags\";\n  payload: {\n    flags: Array<string>;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetFlagsError = {\n  type: \"set-flags-error\";\n  payload: {\n    error: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetRemotes = {\n  type: \"set-remotes\";\n  payload: {\n    remotes: Array<{\n      name: string;\n      data: {};\n    }>;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetRemotesError = {\n  type: \"set-remotes-error\";\n  payload: {\n    error: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerActions =\n  | ReducerSetFlags\n  | ReducerSetFlagsError\n  | ReducerSetRemotes\n  | ReducerSetRemotesError;\n\nexport const UpStampsContext = createContext<UpStampsContextState>(\n  {} as UpStampsContextState\n);\n\nlet reducer = (state: UpStampsState, action: ReducerActions) => {\n  switch (action.type) {\n    case \"set-flags\":\n      return { ...state, ...action.payload };\n    case \"set-flags-error\":\n      return { ...state, ...action.payload };\n    case \"set-remotes\":\n      return { ...state, ...action.payload };\n    case \"set-remotes-error\":\n      return { ...state, ...action.payload };\n\n    default:\n      throw new Error(`Unhandled action type`);\n  }\n};\n\nexport const UpStampsProvider: React.FC<UpStampsProviderProps> = ({\n  children,\n  clientId,\n  envKey,\n  projectKey\n}) => {\n  const params = {\n    clientId,\n    envKey,\n    projectKey\n  };\n\n  const [state, dispatch] = useReducer(reducer, {\n    loading: true,\n    error: false,\n    flags: [],\n    remotes: [],\n    params\n  });\n\n  const value = useMemo(() => ({ state, dispatch }), [state, dispatch]);\n\n  //Get All Flags on Init\n  useEffect(() => {\n    let ignore = false;\n    //Get All the Flags\n    const onFetchFlags = async () => {\n      try {\n        //If the flags are collected, do not fetch again\n        if (state.flags.length > 0) return;\n        //Service Url\n        const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/flags`;\n\n        //Response with the all the flags\n        const response = await fetch(url);\n        const { flags } = await response.json();\n\n        //Filters flags a creates a simple array\n        const data = flags.map((item: { name: string }) => item.name);\n\n        //Updates the state with the flags\n        if (!ignore) {\n          dispatch({\n            type: \"set-flags\",\n            payload: { flags: data, loading: false }\n          });\n        }\n      } catch (e) {\n        dispatch({\n          type: \"set-flags-error\",\n          payload: { loading: false, error: true }\n        });\n      }\n    };\n    //Get All the Remote Flags\n    const onFetchRemotes = async () => {\n      try {\n        //If the Remotes Flags are collected, do not fetch again\n        if (state.remotes.length > 0) return;\n        //Service Url\n        const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/remotes`;\n\n        //Response with the all the remotes flags\n        const response = await fetch(url);\n        const { remotes } = await response.json();\n\n        //Updates the state with the remotes flags\n        if (!ignore) {\n          dispatch({\n            type: \"set-remotes\",\n            payload: { remotes, loading: false }\n          });\n        }\n      } catch (e) {\n        dispatch({\n          type: \"set-remotes-error\",\n          payload: { loading: false, error: true }\n        });\n      }\n    };\n    onFetchFlags();\n    onFetchRemotes();\n    return () => {\n      ignore = true;\n    };\n  }, []);\n\n  return (\n    <UpStampsContext.Provider value={value}>\n      {children}\n    </UpStampsContext.Provider>\n  );\n};\n","import { useContext } from \"react\";\nimport { UpStampsContext } from \"./Context\";\n\nconst useUpStampsContext = () => {\n  const context = useContext(UpStampsContext);\n  if (context === undefined) {\n    throw new Error(\"UpStampsContext must be used with UpStampsProvider!\");\n  }\n  return context;\n};\n\nexport default useUpStampsContext;\n","import { useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport const useFlag = (name: string) => {\n  const { state } = useUpstampsContext();\n  const flags = useMemo(() => state.flags, [state.flags]);\n\n  return {\n    show: flags.indexOf(name) !== -1,\n  } as const;\n};\n","import React, { Fragment, useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport interface FlagProps {\n  children: React.ReactNode;\n  name: string;\n}\n\nexport const Flag: React.FC<FlagProps> = ({ children, name }) => {\n  const { state } = useUpstampsContext();\n  const show = useMemo(() => state.flags.indexOf(name) !== -1, [\n    state.flags,\n    name,\n  ]);\n\n  //Hide the feature\n  if (!show) return null;\n\n  return <Fragment>{children}</Fragment>;\n};\n","import { useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport const useRemoteFlag = (name: string) => {\n  const { state } = useUpstampsContext();\n\n  const remote = useMemo(\n    () => state.remotes.filter((item: any) => item.name === name),\n    [state.remotes, name]\n  );\n  const verifyRemote = useMemo(() => remote.length > 0, [remote]);\n\n  return {\n    show: verifyRemote,\n    data: verifyRemote ? remote[0].data : {},\n  } as { show: boolean; data: {} };\n};\n","import React, { Fragment, useMemo } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport interface RemoteFlagProps {\n  children: any;\n  name: string;\n}\n\nexport const RemoteFlag: React.FC<RemoteFlagProps> = ({ children, name }) => {\n  const { state } = useUpstampsContext();\n\n  const remote = useMemo(\n    () => state.remotes.filter((item: any) => item.name === name),\n    [state.remotes, name]\n  );\n  const verifyRemote = useMemo(() => remote.length > 0, [remote]);\n  const data = verifyRemote ? remote[0].data : {};\n\n  //Hide the feature\n  if (!verifyRemote) return null;\n\n  return <Fragment>{children(data)}</Fragment>;\n};\n","export const variantTypes = [\"A\", \"B\"];\n\nexport const fetchHandler = async (url: string, name: string) => {\n  try {\n    //Response with the all the A/B Tests\n    const response = await fetch(url);\n    const { ABTesting } = await response.json();\n\n    const result = ABTesting.filter((item: any) => item.name === name);\n    const show = result.length > 0;\n    const randomVariant = Math.floor(Math.random() * variantTypes.length);\n\n    return {\n      show,\n      variant: variantTypes[randomVariant],\n      loading: false\n    };\n  } catch (e) {\n    throw e;\n  }\n};\n\nexport const emitterHandler = async (\n  variant: string,\n  name: string,\n  url: string\n) => {\n  try {\n    const post_body = {\n      name,\n      varA: variant === \"A\" ? 1 : 0,\n      varB: variant === \"B\" ? 1 : 0\n    };\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n      body: JSON.stringify(post_body)\n    });\n\n    return await response.json();\n  } catch (e) {\n    return e;\n  }\n};\n","import { useEffect, useState } from \"react\";\n//Context\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { fetchHandler, emitterHandler } from \"./shared\";\n\ninterface IState {\n  loading: boolean;\n  error: boolean;\n  show: boolean;\n  variant: string;\n}\n\nexport const useABTest = (name: string) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    loading: true,\n    error: false,\n    show: false,\n    variant: \"A\"\n  });\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/testing`;\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const { show, loading, variant } = await fetchHandler(url, name);\n\n        setState((prevState: IState) => {\n          return {\n            ...prevState,\n            show,\n            variant,\n            loading\n          };\n        });\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  const onEmitter = async () => {\n    try {\n      return await emitterHandler(state.variant, name, url);\n    } catch (e) {\n      return e;\n    }\n  };\n\n  return {\n    show: state.show,\n    error: state.error,\n    loading: state.loading,\n    variant: state.variant,\n    emitter: onEmitter\n  } as IState | { emitter: () => {} };\n};\n","import React, { Fragment, useEffect, useState } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { fetchHandler, emitterHandler } from \"./shared\";\n\nexport interface ABTestProps {\n  children: React.ReactNode;\n  testRef: React.RefObject<any>;\n  name: string;\n}\n\ninterface IState {\n  component: React.ReactNode;\n  loading: boolean;\n  error: boolean;\n  variant: string;\n  show: boolean;\n}\n\ninterface ContainerProps {\n  children: React.ReactNode;\n  emitter: () => {};\n}\n\nconst Container = React.forwardRef(\n  (props: ContainerProps, ref: React.Ref<any>) => {\n    React.useImperativeHandle(ref, () => ({ emitter: props.emitter }));\n\n    return <Fragment>{props.children}</Fragment>;\n  }\n);\n\nexport const ABTest = ({ children, name, testRef }: ABTestProps) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    component: [],\n    loading: true,\n    error: false,\n    variant: \"A\",\n    show: false\n  });\n\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/testing`;\n\n  const onRenderChildren = (variant: string) => {\n    const component = React.Children.map(children, (child: any) => {\n      if (child.props.name === variant) {\n        return child;\n      }\n    });\n\n    setState((prevState: IState) => {\n      return {\n        ...prevState,\n        component\n      };\n    });\n  };\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const { show, loading, variant } = await fetchHandler(url, name);\n\n        onRenderChildren(variant);\n\n        setState((prevState: IState) => {\n          return {\n            ...prevState,\n            show,\n            variant,\n            loading\n          };\n        });\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  const onEmitter = async () => {\n    try {\n      return await emitterHandler(state.variant, name, url);\n    } catch (e) {\n      return e;\n    }\n  };\n\n  if (!state.loading && !state.show) return null;\n\n  return (\n    <Container ref={testRef} emitter={onEmitter}>\n      {state.component}\n    </Container>\n  );\n};\n\nconst Variant = ({\n  children,\n  name\n}: {\n  children: React.ReactNode;\n  name: string;\n}) => {\n  return React.cloneElement(\n    <Fragment />,\n    { name },\n    <Fragment>{children}</Fragment>\n  );\n};\n\nVariant.displayName = \"ABTest.Variant\";\n\nABTest.Variant = Variant;\n","export const queryBuilder = (params: {}) => {\n  const esc = encodeURIComponent;\n\n  return Object.keys(params)\n    .filter(\n      key => params[key] !== undefined && params[key] && params[key] !== null\n    )\n    .map(key => esc(key) + \"=\" + esc(params[key]))\n    .join(\"&\");\n};\n","//Utils\nimport { queryBuilder } from \"../Utils/functions\";\n\nexport const handleFetch = async (\n  url: string,\n  name: string,\n  params: { country?: string; client?: string; clientType?: string }\n) => {\n  try {\n    const query = queryBuilder({\n      name: name,\n      country: params.country,\n      client: params.client,\n      clientType: params.clientType\n    });\n\n    const response = await fetch(`${url}?${query}`, {\n      method: \"GET\"\n    });\n\n    const { segment } = await response.json();\n    const show = segment.length > 0;\n\n    return {\n      segment,\n      show,\n      loading: false\n    };\n  } catch (e) {\n    throw e;\n  }\n};\n","import { useState, useEffect } from \"react\";\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { handleFetch } from \"./shared\";\n\ninterface IState {\n  loading: boolean;\n  error: boolean;\n  show: boolean;\n}\n\nexport const useSegment = (\n  name: string,\n  params: { country?: string; client?: string; clientType?: string }\n) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    loading: true,\n    error: false,\n    show: false\n  });\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/segment`;\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const { show, loading } = await handleFetch(url, name, params);\n\n        setState((prevState: IState) => {\n          return {\n            ...prevState,\n            show,\n            loading\n          };\n        });\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  return {\n    show: state.show,\n    error: state.error,\n    loading: state.loading\n  } as IState | { emitter: () => {} };\n};\n","import React, { Fragment, useEffect, useState } from \"react\";\n//Utils\nimport { apiUrl } from \"../Utils/constants\";\nimport { handleFetch } from \"./shared\";\n//Context\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\ninterface IState {\n  loading: boolean;\n  error: boolean;\n  show: boolean;\n}\n\nexport interface SegmentProps {\n  children: React.ReactNode;\n  name: string;\n  params: { country?: string; client?: string; clientType?: string };\n}\n\nexport const Segment: React.FC<SegmentProps> = ({ children, name, params }) => {\n  const context = useUpstampsContext();\n  const [state, setState] = useState<IState>({\n    loading: true,\n    error: false,\n    show: false\n  });\n\n  const { clientId, projectKey, envKey } = context.state.params;\n  const url = `${apiUrl}/${clientId}/${projectKey}/${envKey}/segment`;\n\n  useEffect(() => {\n    const onFetch = async () => {\n      try {\n        const { show, loading } = await handleFetch(url, name, params);\n\n        setState((prevState: IState) => {\n          return {\n            ...prevState,\n            show,\n            loading\n          };\n        });\n      } catch (e) {\n        setState((prevState: IState) => {\n          return { ...prevState, error: true, loading: false };\n        });\n      }\n    };\n    onFetch();\n  }, [name, context.state.params]);\n\n  //Hide the feature\n  if (!state.show) return null;\n\n  return <Fragment>{children}</Fragment>;\n};\n","import React, { createContext, useEffect, useReducer, useMemo } from \"react\";\n//Constants\nimport { apiUrl } from \"../Utils/constants\";\n//Contexts\nimport useUpstampsContext from \"../Contexts/useUpstampsContext\";\n\nexport interface ScopesConfigParams {\n  name?: string | null;\n  email: string;\n}\n\nexport interface ScopesState {\n  loading: boolean;\n  error: boolean;\n  params: ScopesConfigParams;\n}\n\nexport interface ScopesContextState {\n  state: ScopesState;\n}\n\nexport interface ScopesProviderProps extends ScopesConfigParams {\n  children: React.ReactNode;\n}\n\nexport type ReducerSetScope = {\n  type: \"set-scope\";\n  payload: {\n    success: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerSetScopeError = {\n  type: \"set-scope-error\";\n  payload: {\n    error: boolean;\n    loading: boolean;\n  };\n};\n\nexport type ReducerScopeActions = ReducerSetScope | ReducerSetScopeError;\n\nexport const ScopesContext = createContext<ScopesContextState>(\n  {} as ScopesContextState\n);\n\nlet reducer = (state: ScopesState, action: ReducerScopeActions) => {\n  switch (action.type) {\n    case \"set-scope\":\n      return { ...state, ...action.payload };\n    case \"set-scope-error\":\n      return { ...state, ...action.payload };\n\n    default:\n      throw new Error(`Unhandled action type`);\n  }\n};\n\nexport const ScopesProvider: React.FC<ScopesProviderProps> = ({\n  children,\n  name,\n  email\n}) => {\n  const context = useUpstampsContext();\n\n  const params = {\n    name,\n    email\n  };\n\n  const [state, dispatch] = useReducer(reducer, {\n    loading: true,\n    error: false,\n    params\n  });\n\n  const { clientId, projectKey } = context.state.params;\n\n  const value = useMemo(() => ({ state, dispatch }), [state, dispatch]);\n\n  useEffect(() => {\n    let ignore = false;\n    const onSetScope = async () => {\n      try {\n        //Service Url\n        const url = `${apiUrl}/${clientId}/${projectKey}/scopes/add`;\n\n        const post_body = {\n          name,\n          email\n        };\n\n        await fetch(url, {\n          method: \"POST\",\n          headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n          body: JSON.stringify(post_body)\n        });\n\n        window.localStorage.setItem(\"upstamps_scope_email\", email);\n\n        if (!ignore) {\n          dispatch({\n            type: \"set-scope\",\n            payload: { success: true, loading: false }\n          });\n        }\n      } catch (e) {\n        dispatch({\n          type: \"set-scope-error\",\n          payload: { loading: false, error: true }\n        });\n      }\n    };\n\n    //Get the email from localStorage\n    const storageEmail = window.localStorage.getItem(\"upstamps_scope_email\");\n\n    //Only set a scope if the email is null or different\n    if (storageEmail !== email) {\n      onSetScope();\n    }\n    return () => {\n      ignore = true;\n    };\n  }, [email]);\n\n  return (\n    <ScopesContext.Provider value={value}>{children}</ScopesContext.Provider>\n  );\n};\n"],"names":["apiUrl","UpStampsContext","createContext","reducer","state","action","type","payload","Error","UpStampsProvider","children","clientId","envKey","projectKey","params","useReducer","loading","error","flags","remotes","dispatch","value","useMemo","useEffect","ignore","onFetchFlags","length","url","fetch","response","json","data","map","item","name","onFetchRemotes","React","Provider","useUpStampsContext","context","useContext","undefined","useFlag","useUpstampsContext","show","indexOf","Flag","Fragment","useRemoteFlag","remote","filter","verifyRemote","RemoteFlag","variantTypes","fetchHandler","ABTesting","result","randomVariant","Math","floor","random","variant","e","emitterHandler","post_body","varA","varB","method","headers","body","JSON","stringify","useABTest","useState","setState","onFetch","prevState","onEmitter","emitter","Container","forwardRef","props","ref","useImperativeHandle","ABTest","testRef","component","onRenderChildren","Children","child","Variant","cloneElement","displayName","queryBuilder","esc","encodeURIComponent","Object","keys","key","join","handleFetch","query","country","client","clientType","segment","useSegment","Segment","ScopesContext","ScopesProvider","email","onSetScope","window","localStorage","setItem","success","storageEmail","getItem"],"mappings":"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"}